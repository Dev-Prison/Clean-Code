# 10. 클래스
## 클래스 체계
- 변수 목록 : 정적 공개 상수 - 정적 비공개 변수 - 비공개 인스턴스
- 변수 목록 이후 공개 함수가 나온다.
- 비공개 함수는 자신을 호출하는 공개 함수 직후에 넣는다
- 즉 추상화 단계가 순차적으로 내려가게 되어 신문기사처럼 프로그램이 읽힌다.

## 캡슐화
- 변수와 유틸리티 함수는 가능한 공개하지 않는 편이 낫지만 반드시 숨겨야 하는 법칙도 없다
- 테스트 코드 작성을 위해 protected 를 활용하기도 한다
- 기본적으로 캡슐화를 풀어주는 결정은 최후의 수단이다

## 클래스는 작아야 한다!
- 클래스는 작아야 한다.
- 그 기준은 클래스가 맡은 책임의 개수와 관련있다
- 클래스 이름은 해당 클래스의 책임을 기술해야 한다.
- 간결한 이름이 떠오르지 않거나 모호하다면 클래스의 크기가 너무 큰것이다
- 클래스 설명은 if, and, or, but 을 사용하지 않으면서 25단어 내외로 가능해야 한다.

## 단일 책임 원칙
- SRP 는 변경할 이유가 하나여야 한다는 의미이다.
- 책임, 즉 변경할 이유를 파악하려 애쓰다 보면 코드를 추상화하기도 쉬워진다. 
- 개발자는 프로그램을 돌아가기만 하면 다음 기능으로 넘어가기 때문에 SRP 를 많이 무시한다.
- 또한 클래스가 많아 큰 그림을 이해하기 어렵다고도 한다.
- 하지만 작은 클래스가 많든 큰 클래스가 있든 돌아가는 부품은 그 수가 비슷하다
- 그렇다면 우리는 어떻게 관리할지에 집중해야 한다.
- 체계적인 정리를 위해 작은 클래스 여러개를 사용하자

## 응집도
- 클래스는 인스턴스 변수 수가 작아야 한다.
- 메서드가 변수를 더 많이 사용할 수록 메서드와 클래스는 응집도가 매우 높다
- 응집도가 높으면 메서드와 변수가 서로 의존하며 논리적인 단위로 묶이는 것을 의미한다
- 이런경우 클래스로 따로 빼버려라

## 응집도를 유지하면 작은 클래스 여럿이 나온다.
- 너무 많은 변수를 사용하는 메서드가 존재하면 함수로 다시 쪼개고 변수를 인스턴스 변수로 승격시킬 수 있다
- 이런 경우 클래스 자체의 응집력을 잃는다.
- 몇몇 함수만 사용하는 인스턴스 변수가 늘기 때문이다
- 이런경우 클래스로 따로 빼라
- 이렇게 프로그램의 체계가 잡히고 구조가 명확해 진다.

```java
예시 코드
1개의 클래스를 여러 클래스로 조갠다.
```
- 리팩터링 시 프로그램 길이가 길어진다.
- 1. 리팩터링한 프로그램은 좀 더 길고 서술적인 변수 이름을 사용한다
- 2. 코드에 주석을 추가하는 수단으로 함수 선언과 클래스 선언을 활용한다
- 3. 가독성을 높이기 위해 공백을 추가하고 형식을 맞춘다.
- 프로그램 재구성이 아니다. 알고리즘과 동작 원리는 동일하다
- 단지 응집도 높은 클래스 유지를 위해 책임을 분할한것이다

## 변경하기 쉬운 클래스 
- 대다수의 시스템은 지속적인 변경이 가해진다
- 이때 변경 지점이 2개 이상이면 곤란하다
- Sql 클래스에는 클래스 일부에서만 사용하는 private 클래스를 가지고 이는 코드 개선지점을 잠재적으로 시사한다
- 변경 지점이 많아지고 이런경우 ocp 를 우반하게 된다.

- 변경한 코드는 추상클래스로 공통 부분을 묶고 해당 클래스를 상속받아 기능별 클래스를 만든다
- 이를 통해 응집도 높은 클래스들로 책임을 분할하였다
- 변경지점은 1개이다
- 기능 추가의 경우 추상클래스를 상속받아 사용하면 되기 때문에 쉽고 수정도 쉽다. OCP 원칙을 따른다

## 변경으로부터 격리
- 상세한 구현에 의존하는 코드는 테스트가 어렵다
- DIP 를 통해 느슨한 결합을 사용할 수 있다.
- 인터페이스를 통해 구현클래스를 만들고
- 해당 인터페이스와 고정된 데이터 값을 통해 테스트 코드를 만들수 있다.
- 즉 테스트가 가능할 정도로 시스템의 결합도를 낮추면 유연성과 재사용성이 높아진다.
- 결합도가 낮으면 각 시스템 요소가 다른 요소로부터 그리고 변경으로부터 잘 격리됨을 의미한다