# 지저분한 코드를 짜봐야하고, 점진적 개선을 해야 하는 이유

> 본격적으로 코드의 어디를 어떻게 개선해나가는지 세세하게 살펴보기전 에 intro 내용
>
- 먼저 엉망인 코드를 짜보자 (돌아가게끔)
    - 이 지저분한 코드를 짜는 과정이 중요하다.
        - ex) 책의 예시처럼, 처리해야 할 Arg 의 타입이 추가됨에 따라 코드가 지저분해지는 상황을 생각 해보자 → 지저분해지는 위치들이 있음! 책에서는 parse, get, set 의 세 곳이 항상 더러워졌다 —> 이런 부분을 파악하기 위해서는 지저분한 코드를 작성해 봐야 한다.
- 코드는 왜 엉망이 되는 걸까?
    - 분명 처음에 주어진 요구사항에 대해서는 깔끔한 코드였을 것이다.
    - 요구사항이 추가됨에 따라 내 손을 벗어나게 된다.
        - ex) 책의 예시 처럼, 처리해야 할 Arg 의 ‘타입’ 이 추가됨에 따라 코드가 지저분해 지기 시작한다.
- 코드가 엉망이 되기 시작하는게 보인다면 멈춰야 한다!!
    - 기능을 더 이상 추가 하지 말고, 리팩토링을 해야 한다!
- 한 번에 바꾸는 게 아니다. 점진적으로 개선해야 한다.
    - 개선이라는 이름 아래에 ‘구조’를 한 번에 뒤집어선 안된다.
    - 개선 후에도 시스템은 전과 같이 돌아가야 하므로 ‘언제든 실행가능한 자동화된 테스트 suite’ 를 작성해 두자.
- 코드에 나오는 marshelling : 표현방식을, ‘적합한 다른 데이터 형식’으로 변환하는 과정을 의미
- 코드를 보면서 느낀 점
    - 생성자 로직 내부에서 불변식 만족 여부를 반드시 체크하고 , 만족하지 않을 경우 실패하도록 작성하는 것은 중요하다.
        - 책의 예시에서는 (최종 리팩토링 된 코드) Args 라는 인스턴스가 생성되었다면, 이후에는 해당 인스턴스에 어떤 질의든 던질 수 있음을 의미하고 있다.
    - 각 메서드들의 배열 : 코드를 위에서 아래로 내려가며 읽을 수 있도록 배치된 코드들
    - 코드가 다소 장황함
        - Java 라는 언어의 특성 때문
        - 정적 타입 시스템을 만족하기 위해서는 많은 단어가 필요하다.
            - 비교 : Kotlin

            ```java
            fun CoroutineScope.square(numbers: ReceiveChannel<Int>): ReceiveChannel<Int> = produce {
                for (x in numbers) // Java 는 개선된 for 문에서도 타입 명시가 필요함
            // Java 에도 var 과 같은것이 도입되긴 하였음 
            ```


# 어떻게 개선해 나갔는가?

(다음 내용)
